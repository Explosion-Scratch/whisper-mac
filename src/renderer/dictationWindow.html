<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Dictation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        background: transparent;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display",
          "Helvetica Neue", Arial, sans-serif;
        color-scheme: light dark;
        background: rgba(250, 250, 252, 0.06);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2),
          0 2px 10px rgba(0, 0, 0, 0.08);
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        transition: box-shadow 0.2s ease, border-color 0.2s ease,
          background 0.2s ease;
        background-clip: padding-box;
      }

      body:hover {
        box-shadow: 0 14px 56px rgba(0, 0, 0, 0.22),
          0 6px 16px rgba(0, 0, 0, 0.1);
      }

      .dictation-container {
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        height: 48px;
        min-height: 48px;
        max-height: 48px;
        -webkit-app-region: drag; /* Make the entire container draggable */
        cursor: grab;
        transition: cursor 0.2s ease;
        position: relative;
      }

      .dictation-container:active {
        cursor: grabbing;
      }

      /* Make interactive elements non-draggable */
      .status-icon,
      .close-button,
      .text-scroll-container {
        -webkit-app-region: no-drag;
        cursor: default;
      }

      .close-button {
        cursor: pointer;
      }

      .text-scroll-container {
        cursor: text;
      }

      .status-icon {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        /* stronger, simple border + shadow for better contrast */
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.14);
        transform: scale(1);
        animation: statusIconEnter 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .status-icon:hover {
        transform: scale(1.05);
      }

      .status-icon.recording {
        display: none;
      }

      .status-icon.idle {
        background: rgba(52, 199, 89, 0.92);
      }

      .status-icon.transforming {
        background: rgba(255, 159, 10, 0.92);
        animation: statusIconPulse 2s ease-in-out infinite;
      }

      .status-icon.complete {
        background: rgba(52, 199, 89, 0.92);
        animation: statusIconSuccess 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .status-icon svg {
        width: 14px;
        height: 14px;
        fill: white;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .text-scroll-container {
        flex: 1;
        overflow-x: auto;
        overflow-y: hidden;
        position: relative;
        height: 24px;
        display: flex;
        align-items: center;
        scrollbar-width: none;
        -ms-overflow-style: none;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .text-scroll-container::-webkit-scrollbar {
        display: none;
      }

      .wave-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
      }

      .wave-container.active {
        opacity: 1;
      }

      .wave-canvas {
        width: 100%;
        height: 24px;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .text-content {
        display: flex;
        align-items: baseline;
        gap: 4px;
        white-space: nowrap;
        min-width: 100%;
        line-height: 1.2;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .text-content.hidden {
        opacity: 0;
      }

      .text-segment {
        font-size: 13px;
        color: #0b0b0c66; /* increased contrast */
        font-weight: 300;
        display: inline-block;
        line-height: 1.2;
        text-shadow: none; /* remove soft glow to improve legibility */
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .text-segment.transcribed {
        color: #0b0b0c;
      }

      .text-segment.in-progress {
        color: #6b6b70; /* darker grey for better contrast */
      }

      .text-segment.in-progress::after {
        content: "|";
        animation: blink 1.2s ease-in-out infinite;
        margin-left: 1px;
        font-weight: 300;
        vertical-align: baseline;
        line-height: 1.2;
      }

      .separator {
        color: #6e6e73;
        font-size: 12px;
        margin: 0 4px;
        text-shadow: none;
        transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.1);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @keyframes fastSpin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @keyframes waveFadeIn {
        0% {
          opacity: 0;
          transform: scale(0.95);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes waveFadeOut {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(0.95);
        }
      }

      @keyframes statusIconEnter {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      @keyframes statusIconPulse {
        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.14);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 2px 8px rgba(255, 159, 10, 0.3);
        }
      }

      @keyframes statusIconSuccess {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
        }
        100% {
          transform: scale(1);
        }
      }

      .status-icon.transforming svg {
        animation: fastSpin 0.6s linear infinite;
      }

      @keyframes blink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
        100% {
          opacity: 1;
        }
      }

      .close-button {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: rgba(255, 59, 48, 0.35);
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        flex-shrink: 0;
        box-shadow: inset 0 0 0 0.5px rgba(255, 255, 255, 0.6),
          0 1px 2px rgba(0, 0, 0, 0.08);
        transform: scale(1);
      }

      .close-button:hover {
        background: rgba(255, 69, 58, 0.5);
        transform: scale(1.05);
      }

      .close-button svg {
        width: 10px;
        height: 10px;
        fill: white;
        transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @media (prefers-color-scheme: dark) {
        body {
          background: rgba(30, 30, 30, 0.5);
          border-color: rgba(255, 255, 255, 0.12);
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
            0 6px 18px rgba(0, 0, 0, 0.3);
          background-image: linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.06),
            rgba(255, 255, 255, 0.02)
          );
        }

        body:hover {
          box-shadow: 0 22px 70px rgba(0, 0, 0, 0.55),
            0 8px 22px rgba(0, 0, 0, 0.35);
        }

        .text-segment {
          color: #f2f2f7;
          text-shadow: 0 1px 1px rgba(0, 0, 0, 0.35);
        }

        .text-segment.transcribed {
          color: #f2f2f7;
        }

        .text-segment.in-progress {
          color: #8e8e93;
        }

        .separator {
          color: #8e8e93;
          text-shadow: 0 1px 1px rgba(0, 0, 0, 0.25);
        }
      }

      @media (prefers-reduced-transparency: reduce) {
        body {
          backdrop-filter: none;
          -webkit-backdrop-filter: none;
          background: #f5f5f7;
          border-color: rgba(0, 0, 0, 0.1);
        }
        @media (prefers-color-scheme: dark) {
          body {
            background: #1c1c1e;
            border-color: rgba(255, 255, 255, 0.12);
          }
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="dictation-container">
        <div class="status-icon" :class="statusIconClass">
          <!-- Microphone icon for idle state using Phosphor -->
          <svg v-if="currentStatus === 'idle'" viewBox="0 0 256 256">
            <path
              fill="currentColor"
              d="M128 174a46.06 46.06 0 0 0 46-46V64a46 46 0 0 0-92 0v64a46.06 46.06 0 0 0 46 46M94 64a34 34 0 0 1 68 0v64a34 34 0 0 1-68 0Zm40 141.75V240a6 6 0 0 1-12 0v-34.25A78.09 78.09 0 0 1 50 128a6 6 0 0 1 12 0a66 66 0 0 0 132 0a6 6 0 0 1 12 0a78.09 78.09 0 0 1-72 77.75"
            />
          </svg>

          <!-- Loading spinner for transforming state -->
          <svg v-else-if="currentStatus === 'transforming'" viewBox="0 0 24 24">
            <g fill="none" fill-rule="evenodd">
              <path
                d="m12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035q-.016-.005-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427q-.004-.016-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093q.019.005.029-.008l.004-.014l-.034-.614q-.005-.018-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014l-.034.614q.001.018.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"
              />
              <path
                fill="currentColor"
                d="M12 4a8 8 0 1 0 0 16a8 8 0 0 0 0-16M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12"
                opacity=".1"
              />
              <path
                fill="currentColor"
                d="M12 4a7.96 7.96 0 0 0-5.533 2.222a1 1 0 1 1-1.384-1.444A9.96 9.96 0 0 1 12 2a1 1 0 1 1 0 2"
              />
            </g>
          </svg>

          <!-- Check icon for complete state using Phosphor -->
          <svg v-else-if="currentStatus === 'complete'" viewBox="0 0 256 256">
            <path
              fill="currentColor"
              d="m229.66 77.66l-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69L218.34 66.34a8 8 0 0 1 11.32 11.32"
            />
          </svg>
        </div>

        <div class="text-scroll-container" ref="textScrollContainer">
          <div
            class="wave-container"
            :class="{ active: currentStatus === 'listening' }"
          >
            <canvas
              v-show="currentStatus === 'listening'"
              id="waveform"
              class="wave-canvas"
              height="24"
              width="200"
            ></canvas>
          </div>
          <div
            class="text-content"
            :class="{ hidden: currentStatus === 'listening' }"
            ref="textContent"
          >
            <span
              v-if="currentStatus === 'transforming'"
              class="text-segment in-progress"
            >
              Processing...
            </span>
            <span
              v-else-if="currentStatus === 'complete' && finalText"
              class="text-segment transcribed"
            >
              {{ finalText }}
            </span>
            <span
              v-else-if="currentStatus !== 'listening'"
              class="text-segment"
            >
              Ready
            </span>
          </div>
        </div>

        <button class="close-button" @click="handleClose">
          <!-- X icon using Phosphor -->
          <svg viewBox="0 0 256 256">
            <path
              d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"
            />
          </svg>
        </button>
      </div>
    </div>
    <script src="./vue.js"></script>
    <script>
      const { createApp, ref, computed, onMounted, nextTick, watch } = Vue;

      createApp({
        setup() {
          // Reactive state
          const isRecording = ref(false);
          const currentStatus = ref("idle");
          const finalText = ref("");
          const audioLevel = ref(0);

          let waveCanvas = null;
          let waveCtx = null;
          let waveAnim = null;

          const loudnessHistory = ref([]);
          const MAX_HISTORY = 64;
          let smoothedLevel = 0;

          // Computed properties
          const statusIconClass = computed(() => ({
            recording: currentStatus.value === "listening",
            idle: currentStatus.value === "idle",
            transforming: currentStatus.value === "transforming",
            complete: currentStatus.value === "complete",
          }));

          const textContent = ref(null);
          const textScrollContainer = ref(null);

          const scrollToEnd = () => {
            if (textScrollContainer.value) {
              textScrollContainer.value.scrollLeft =
                textScrollContainer.value.scrollWidth;
            }
          };

          const initializeWaveCanvas = () => {
            const canvas = document.getElementById("waveform");
            if (canvas) {
              waveCanvas = canvas;
              waveCtx = canvas.getContext("2d");

              // Set canvas to full width of container
              const container = textScrollContainer.value;
              if (container) {
                canvas.width = container.offsetWidth;
                canvas.style.width = "100%";
              }

              console.log("Wave canvas initialized:", !!waveCanvas, !!waveCtx);
            } else {
              console.warn("Wave canvas not found in DOM");
            }
          };

          const drawLoudnessHistory = () => {
            if (
              !waveCtx ||
              !waveCanvas ||
              currentStatus.value !== "listening"
            ) {
              if (waveAnim) {
                cancelAnimationFrame(waveAnim);
                waveAnim = null;
              }
              return;
            }

            // Update canvas width if container size changed
            const container = textScrollContainer.value;
            if (container && waveCanvas.width !== container.offsetWidth) {
              waveCanvas.width = container.offsetWidth;
            }

            const w = waveCanvas.width;
            const h = waveCanvas.height;
            const centerY = h / 2;

            waveCtx.clearRect(0, 0, w, h);

            const isDarkMode =
              window.matchMedia &&
              window.matchMedia("(prefers-color-scheme: dark)").matches;

            waveCtx.lineWidth = 1.5;
            waveCtx.strokeStyle = isDarkMode
              ? "rgba(255, 255, 255, 0.7)"
              : "rgba(0, 0, 0, 0.7)";

            waveCtx.beginPath();

            const history = loudnessHistory.value;
            const len = history.length;
            const step = w / (MAX_HISTORY - 1);

            if (len > 1) {
              // Top path
              waveCtx.moveTo(0, centerY - (history[0] || 0) * (h / 2) * 0.9);
              for (let i = 1; i < len; i++) {
                const x = i * step;
                const amplitude = history[i] * (h / 2) * 0.9;
                waveCtx.lineTo(x, centerY - amplitude);
              }

              // Mirrored bottom path
              for (let i = len - 1; i >= 0; i--) {
                const x = i * step;
                const amplitude = history[i] * (h / 2) * 0.9;
                waveCtx.lineTo(x, centerY + amplitude);
              }
              waveCtx.closePath();
              waveCtx.stroke();
            }

            waveAnim = requestAnimationFrame(drawLoudnessHistory);
          };

          // Methods
          const resetState = () => {
            finalText.value = "";
            loudnessHistory.value = [];
            smoothedLevel = 0;

            // Smooth transition to listening state
            currentStatus.value = "listening";

            // Ensure wave canvas is initialized when resetting to listening state
            nextTick(() => {
              initializeWaveCanvas();
              if (currentStatus.value === "listening" && !waveAnim) {
                waveAnim = requestAnimationFrame(drawLoudnessHistory);
              }
            });
          };

          const handleClose = () => {
            window.electronAPI.closeDictationWindow();
          };

          // IPC event handlers
          const initializeDictation = (data) => {
            console.log("Initializing dictation with data:", data);
            resetState();

            // Ensure wave canvas is initialized on window initialization
            nextTick(() => {
              initializeWaveCanvas();
              if (currentStatus.value === "listening" && !waveAnim) {
                waveAnim = requestAnimationFrame(drawLoudnessHistory);
              }
            });
          };

          const startRecording = () => {
            console.log("Recording started");
            isRecording.value = true;
            currentStatus.value = "listening";
            resetState();

            nextTick(() => {
              initializeWaveCanvas();
              if (!waveAnim) {
                waveAnim = requestAnimationFrame(drawLoudnessHistory);
              }
            });
          };

          const stopRecording = () => {
            console.log("Recording stopped");
            isRecording.value = false;
            currentStatus.value = "transforming";
            if (waveAnim) {
              cancelAnimationFrame(waveAnim);
              waveAnim = null;
            }
          };

          const updateTranscription = (update) => {
            console.log("Transcription update:", update);
            if (update.status === "transforming") {
              currentStatus.value = "transforming";
            }
          };

          const completeDictation = (text) => {
            console.log("Dictation complete:", text);
            finalText.value = text;
            currentStatus.value = "complete";
            if (waveAnim) {
              cancelAnimationFrame(waveAnim);
              waveAnim = null;
            }
          };

          const clearDictation = () => {
            console.log("Clearing dictation window");
            currentStatus.value = "idle";
            isRecording.value = false;

            // Stop animation when clearing
            if (waveAnim) {
              cancelAnimationFrame(waveAnim);
              waveAnim = null;
            }

            resetState();
          };

          // Watch for text changes and scroll to end
          watch([finalText], () => {
            nextTick(() => {
              scrollToEnd();
            });
          });

          // Watch for status changes to ensure wave animation starts
          watch([currentStatus], (newStatus) => {
            if (newStatus[0] === "listening") {
              nextTick(() => {
                initializeWaveCanvas();
                if (!waveAnim) {
                  waveAnim = requestAnimationFrame(drawLoudnessHistory);
                }
              });
            } else if (newStatus[0] !== "listening" && waveAnim) {
              cancelAnimationFrame(waveAnim);
              waveAnim = null;
            }
          });

          // Setup IPC listeners
          onMounted(() => {
            window.electronAPI.onInitializeDictation(initializeDictation);
            window.electronAPI.onStartRecording(startRecording);
            window.electronAPI.onStopRecording(stopRecording);
            window.electronAPI.onTranscriptionUpdate(updateTranscription);
            window.electronAPI.onDictationComplete(completeDictation);
            window.electronAPI.onDictationClear(clearDictation);

            window.electronAPI.onAudioLevel((lvl) => {
              const newLevel = Math.max(0, Math.min(1, lvl));
              audioLevel.value = newLevel;

              if (currentStatus.value === "listening") {
                smoothedLevel = smoothedLevel * 0.6 + newLevel * 0.4;
                loudnessHistory.value.push(smoothedLevel);
                if (loudnessHistory.value.length > MAX_HISTORY) {
                  loudnessHistory.value.shift();
                }
              }
            });

            // Prevent default drag behavior
            document.addEventListener("dragstart", (e) => e.preventDefault());

            // Initialize wave canvas on mount
            nextTick(() => {
              initializeWaveCanvas();

              // Add resize observer for responsive canvas
              if (textScrollContainer.value) {
                const resizeObserver = new ResizeObserver(() => {
                  if (waveCanvas && currentStatus.value === "listening") {
                    waveCanvas.width = textScrollContainer.value.offsetWidth;
                  }
                });
                resizeObserver.observe(textScrollContainer.value);
              }
            });
          });

          return {
            // State
            isRecording,
            currentStatus,
            finalText,
            audioLevel,

            // Computed
            statusIconClass,
            textContent,
            textScrollContainer,

            // Methods
            handleClose,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
